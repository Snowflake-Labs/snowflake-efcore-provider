// <auto-generated />

using System;
using System.Reflection;
using System.Resources;
using System.Text.RegularExpressions;
using System.Threading;
using Microsoft.EntityFrameworkCore.Diagnostics;
using Microsoft.EntityFrameworkCore.Internal;
using Microsoft.Extensions.Logging;
using Snowflake.EntityFrameworkCore.Diagnostics;

#nullable enable

namespace Snowflake.EntityFrameworkCore.Internal
{
    
    public static class SnowflakeStrings
    {
        private static readonly ResourceManager _resourceManager
            = new ResourceManager("Snowflake.EntityFrameworkCore.Properties.SnowflakeStrings", typeof(SnowflakeStrings).Assembly);

        /// <summary>
        /// Adding a foreign key to an exiting hybrid table is not supported.
        /// </summary>
        public static string AddingForeignKeyToAnExitingHybridTable(string tableName) => string.Format(GetString("AddingForeignKeyToAnExitingHybridTable", nameof(tableName)), tableName);

        /// <summary>
        /// To change the IDENTITY property of a column, the column needs to be dropped and recreated.
        /// Snowflake only supports foreign keys in Hybrid tables during creation.
        /// </summary>
        public static string AddForeginKeyToHybridTable => GetString("AddForeginKeyToHybridTable");

        /// <summary>
        /// RESTART SEQUENCE operation is not supported in Snowflake.
        /// </summary>
        public static string RestartSequenceNotSupported => GetString("RestartSequenceNotSupported");
        
        /// <summary>
        /// Gets the localized string for the message indicating that a unique constraint was not created.
        /// </summary>
        /// <value>
        /// A localized string that describes the error when a unique constraint is not created.
        /// </value>
        public static string UniqueConstraintNotCreated => GetString("UniqueConstraintNotCreated");

        /// <summary>
        /// Adding a CHECK constraint is not supported in Snowflake. This issue occurred while trying to generate a CHECK constraint '{operationName}' for the table '{tableName}'
        /// </summary>
        public static string AddCheckConstraintNotSupported(string? operationName, string? tableName)
            => string.Format(GetString("AddCheckConstraintNotSupported", nameof(operationName), nameof(tableName)), operationName, tableName);

        /// <summary>
        /// Drop a CHECK constraint is not supported in Snowflake. This issue occurred while trying to remove a CHECK constraint '{operationName}' for the table '{tableName}'
        /// </summary>
        public static string DropCheckConstraintNotSupported(string? operationName, string? tableName)
            => string.Format(GetString("DropCheckConstraintNotSupported", nameof(operationName), nameof(tableName)), operationName, tableName);

        /// <summary>
        ///  To add IDENTITY to a column, the column needs to be dropped and recreated.
        /// </summary>
        public static string AlterIdentityColumn
            => GetString("AlterIdentityColumn");
        
        /// <summary>
        ///     Translating this query requires the SQL APPLY operation, which is not supported on Snowflake.
        /// </summary>
        public static string ApplyNotSupported
            => GetString("ApplyNotSupported");

        /// <summary>
        /// To change the COLLATION property of a column, the column needs to be dropped and recreated.
        /// </summary>
        public static string AlterCollationColumn => GetString("AlterCollationColumn");
        
        /// <summary>
        /// To change the column type, you need to explicitly specify the type.
        /// </summary>
        public static string AlterColumnType => GetString("AlterColumnType");

        /// <summary>
        ///     Can't produce unterminated SQL with comments when generating migrations SQL for {operation}.
        /// </summary>
        public static string CannotProduceUnterminatedSQLWithComments(object? operation)
            => string.Format(
                GetString("CannotProduceUnterminatedSQLWithComments", nameof(operation)),
                operation);

        /// <summary>
        ///     EF Core's Snowflake compatibility level is set to {compatibilityLevel}; compatibility level 130 (Snowflake 2016) is the minimum for most forms of querying of JSON arrays.
        /// </summary>
        public static string CompatibilityLevelTooLowForScalarCollections(object? compatibilityLevel)
            => string.Format(
                GetString("CompatibilityLevelTooLowForScalarCollections", nameof(compatibilityLevel)),
                compatibilityLevel);

        /// <summary>
        ///   Adding or dropping constraints is not supported in hybrid tables after table creation. {operationName} on '{tableName}' is an invalid operation.
        /// </summary>
        public static string ConstraintOperationNotSupported(string operationName, string tableName)
        {

            var operationFriendlyName = operationName.Replace("Operation", "");
            operationFriendlyName = Regex.Replace(operationFriendlyName, "(?<!^)([A-Z])", " $1");
            operationFriendlyName = operationFriendlyName[0].ToString().ToUpper() + operationFriendlyName.Substring(1).ToLower();

            return string.Format(
                GetString("ConstraintOperationNotSupported", nameof(operationName), nameof(tableName)),
                operationFriendlyName, tableName);
        }
        
        /// <summary>
        ///     Add Column operation does not support default values for '{columnType}' columns.
        /// </summary>
        public static string DefaultValueInAddColumnNotSupported(object? columnType)
            => string.Format(
                GetString("DefaultValueInAddColumnNotSupported", nameof(columnType)),
                columnType);

        /// <summary>
        ///     '{entityType1}.{property1}' and '{entityType2}.{property2}' are both mapped to column '{columnName}' in '{table}', but are configured with different identity increment values.
        /// </summary>
        public static string DuplicateColumnIdentityIncrementMismatch(object? entityType1, object? property1, object? entityType2, object? property2, object? columnName, object? table)
            => string.Format(
                GetString("DuplicateColumnIdentityIncrementMismatch", nameof(entityType1), nameof(property1), nameof(entityType2), nameof(property2), nameof(columnName), nameof(table)),
                entityType1, property1, entityType2, property2, columnName, table);

        /// <summary>
        ///     '{entityType1}.{property1}' and '{entityType2}.{property2}' are both mapped to column '{columnName}' in '{table}', but are configured with different identity seed values.
        /// </summary>
        public static string DuplicateColumnIdentitySeedMismatch(object? entityType1, object? property1, object? entityType2, object? property2, object? columnName, object? table)
            => string.Format(
                GetString("DuplicateColumnIdentitySeedMismatch", nameof(entityType1), nameof(property1), nameof(entityType2), nameof(property2), nameof(columnName), nameof(table)),
                entityType1, property1, entityType2, property2, columnName, table);

        /// <summary>
        ///     '{entityType1}.{property1}' and '{entityType2}.{property2}' are both mapped to column '{columnName}' in '{table}', but are configured with different value generation strategies.
        /// </summary>
        public static string DuplicateColumnNameValueGenerationStrategyMismatch(object? entityType1, object? property1, object? entityType2, object? property2, object? columnName, object? table)
            => string.Format(
                GetString("DuplicateColumnNameValueGenerationStrategyMismatch", nameof(entityType1), nameof(property1), nameof(entityType2), nameof(property2), nameof(columnName), nameof(table)),
                entityType1, property1, entityType2, property2, columnName, table);

        /// <summary>
        ///     '{entityType1}.{property1}' and '{entityType2}.{property2}' are both mapped to column '{columnName}' in '{table}', but are configured with different hi-lo sequences.
        /// </summary>
        public static string DuplicateColumnSequenceMismatch(object? entityType1, object? property1, object? entityType2, object? property2, object? columnName, object? table)
            => string.Format(
                GetString("DuplicateColumnSequenceMismatch", nameof(entityType1), nameof(property1), nameof(entityType2), nameof(property2), nameof(columnName), nameof(table)),
                entityType1, property1, entityType2, property2, columnName, table);

        /// <summary>
        ///     '{entityType1}.{property1}' and '{entityType2}.{property2}' are both mapped to column '{columnName}' in '{table}', but are configured with different sparseness.
        /// </summary>
        public static string DuplicateColumnSparsenessMismatch(object? entityType1, object? property1, object? entityType2, object? property2, object? columnName, object? table)
            => string.Format(
                GetString("DuplicateColumnSparsenessMismatch", nameof(entityType1), nameof(property1), nameof(entityType2), nameof(property2), nameof(columnName), nameof(table)),
                entityType1, property1, entityType2, property2, columnName, table);

        /// <summary>
        ///     The indexes {index1} on '{entityType1}' and {index2} on '{entityType2}' are both mapped to '{table}.{indexName}', but have different clustered configurations.
        /// </summary>
        public static string DuplicateIndexClusteredMismatch(object? index1, object? entityType1, object? index2, object? entityType2, object? table, object? indexName)
            => string.Format(
                GetString("DuplicateIndexClusteredMismatch", nameof(index1), nameof(entityType1), nameof(index2), nameof(entityType2), nameof(table), nameof(indexName)),
                index1, entityType1, index2, entityType2, table, indexName);

        /// <summary>
        ///     The indexes {index1} on '{entityType1}' and {index2} on '{entityType2}' are both mapped to '{table}.{indexName}', but have different data compression configurations.
        /// </summary>
        public static string DuplicateIndexDataCompressionMismatch(object? index1, object? entityType1, object? index2, object? entityType2, object? table, object? indexName)
            => string.Format(
                GetString("DuplicateIndexDataCompressionMismatch", nameof(index1), nameof(entityType1), nameof(index2), nameof(entityType2), nameof(table), nameof(indexName)),
                index1, entityType1, index2, entityType2, table, indexName);

        /// <summary>
        ///     The indexes {index1} on '{entityType1}' and {index2} on '{entityType2}' are both mapped to '{table}.{indexName}', but have different fill factor configurations.
        /// </summary>
        public static string DuplicateIndexFillFactorMismatch(object? index1, object? entityType1, object? index2, object? entityType2, object? table, object? indexName)
            => string.Format(
                GetString("DuplicateIndexFillFactorMismatch", nameof(index1), nameof(entityType1), nameof(index2), nameof(entityType2), nameof(table), nameof(indexName)),
                index1, entityType1, index2, entityType2, table, indexName);

        /// <summary>
        ///     The indexes {index1} on '{entityType1}' and {index2} on '{entityType2}' are both mapped to '{table}.{indexName}', but have different included columns: {includedColumns1} and {includedColumns2}.
        /// </summary>
        public static string DuplicateIndexIncludedMismatch(object? index1, object? entityType1, object? index2, object? entityType2, object? table, object? indexName, object? includedColumns1, object? includedColumns2)
            => string.Format(
                GetString("DuplicateIndexIncludedMismatch", nameof(index1), nameof(entityType1), nameof(index2), nameof(entityType2), nameof(table), nameof(indexName), nameof(includedColumns1), nameof(includedColumns2)),
                index1, entityType1, index2, entityType2, table, indexName, includedColumns1, includedColumns2);

        /// <summary>
        ///     The indexes {index1} on '{entityType1}' and {index2} on '{entityType2}' are both mapped to '{table}.{indexName}', but have different online configurations.
        /// </summary>
        public static string DuplicateIndexOnlineMismatch(object? index1, object? entityType1, object? index2, object? entityType2, object? table, object? indexName)
            => string.Format(
                GetString("DuplicateIndexOnlineMismatch", nameof(index1), nameof(entityType1), nameof(index2), nameof(entityType2), nameof(table), nameof(indexName)),
                index1, entityType1, index2, entityType2, table, indexName);

        /// <summary>
        ///     The indexes {index1} on '{entityType1}' and {index2} on '{entityType2}' are both mapped to '{table}.{indexName}', but have different sort in tempdb configurations.
        /// </summary>
        public static string DuplicateIndexSortInTempDbMismatch(object? index1, object? entityType1, object? index2, object? entityType2, object? table, object? indexName)
            => string.Format(
                GetString("DuplicateIndexSortInTempDbMismatch", nameof(index1), nameof(entityType1), nameof(index2), nameof(entityType2), nameof(table), nameof(indexName)),
                index1, entityType1, index2, entityType2, table, indexName);

        /// <summary>
        ///     The keys {key1} on '{entityType1}' and {key2} on '{entityType2}' are both mapped to '{table}.{keyName}', but have different clustering configurations.
        /// </summary>
        public static string DuplicateKeyMismatchedClustering(object? key1, object? entityType1, object? key2, object? entityType2, object? table, object? keyName)
            => string.Format(
                GetString("DuplicateKeyMismatchedClustering", nameof(key1), nameof(entityType1), nameof(key2), nameof(entityType2), nameof(table), nameof(keyName)),
                key1, entityType1, key2, entityType2, table, keyName);

        /// <summary>
        ///     Identity value generation cannot be used for the property '{property}' on entity type '{entityType}' because the property type is '{propertyType}'. Identity value generation can only be used with signed integer properties.
        /// </summary>
        public static string IdentityBadType(object? property, object? entityType, object? propertyType)
            => string.Format(
                GetString("IdentityBadType", nameof(property), nameof(entityType), nameof(propertyType)),
                property, entityType, propertyType);

        /// <summary>
        ///     The include property '{entityType}.{property}' was specified multiple times for the index {index}.
        /// </summary>
        public static string IncludePropertyDuplicated(object? entityType, object? property, object? index)
            => string.Format(
                GetString("IncludePropertyDuplicated", nameof(entityType), nameof(property), nameof(index)),
                entityType, property, index);

        /// <summary>
        ///     The include property '{entityType}.{property}' is already part of the index {index}.
        /// </summary>
        public static string IncludePropertyInIndex(object? entityType, object? property, object? index)
            => string.Format(
                GetString("IncludePropertyInIndex", nameof(entityType), nameof(property), nameof(index)),
                entityType, property, index);

        /// <summary>
        ///     The include property '{property}' specified on the index {index} was not found on entity type '{entityType}'.
        /// </summary>
        public static string IncludePropertyNotFound(object? property, object? index, object? entityType)
            => string.Format(
                GetString("IncludePropertyNotFound", nameof(property), nameof(index), nameof(entityType)),
                property, index, entityType);

        /// <summary>
        ///     Cannot use table '{table}' for entity type '{entityType}' since it is being used for entity type '{otherEntityType}' and entity type '{entityTypeWithSqlOutputClause}' is configured to use the SQL OUTPUT clause, but entity type '{entityTypeWithoutSqlOutputClause}' is not.
        /// </summary>
        public static string IncompatibleSqlOutputClauseMismatch(object? table, object? entityType, object? otherEntityType, object? entityTypeWithSqlOutputClause, object? entityTypeWithoutSqlOutputClause)
            => string.Format(
                GetString("IncompatibleSqlOutputClauseMismatch", nameof(table), nameof(entityType), nameof(otherEntityType), nameof(entityTypeWithSqlOutputClause), nameof(entityTypeWithoutSqlOutputClause)),
                table, entityType, otherEntityType, entityTypeWithSqlOutputClause, entityTypeWithoutSqlOutputClause);

        /// <summary>
        ///     Cannot use table '{table}' for entity type '{entityType}' since it is being used for entity type '{otherEntityType}' and entity type '{memoryOptimizedEntityType}' is marked as memory-optimized, but entity type '{nonMemoryOptimizedEntityType}' is not.
        /// </summary>
        public static string IncompatibleTableMemoryOptimizedMismatch(object? table, object? entityType, object? otherEntityType, object? memoryOptimizedEntityType, object? nonMemoryOptimizedEntityType)
            => string.Format(
                GetString("IncompatibleTableMemoryOptimizedMismatch", nameof(table), nameof(entityType), nameof(otherEntityType), nameof(memoryOptimizedEntityType), nameof(nonMemoryOptimizedEntityType)),
                table, entityType, otherEntityType, memoryOptimizedEntityType, nonMemoryOptimizedEntityType);

        /// <summary>
        ///     Snowflake requires the table name to be specified for index operations. Specify table name in calls to 'MigrationBuilder.RenameIndex' and 'DropIndex'.
        /// </summary>
        public static string IndexTableRequired
            => GetString("IndexTableRequired");
        
        /// <summary>
        ///     Snowflake only support indexes within Hybrid Tables. The index '{tableName}' is invalid.
        /// </summary>
        public static string IndexOnlySupportedWithinHybridTables(object? indexName, object? tableName)
            => string.Format(
                GetString("IndexOnlySupportedWithinHybridTables", nameof(indexName), nameof(tableName)),
                indexName, tableName);

        /// <summary>
        ///     The INCLUDE columns option is not supported in the CREATE INDEX statement in Snowflake. This issue occurred while generating the index '{indexName}' on the table '{tableName}'.
        /// </summary>
        public static string IndexWithIncludeOptionIsNotCurrentlySupported(object? indexName, object? tableName)
            => string.Format(
                GetString("IndexWithIncludeOptionIsNotCurrentlySupported", nameof(indexName), nameof(tableName)),
                indexName, tableName);
        
        /// <summary>
        ///     The expression passed to the 'propertyReference' parameter of the 'FreeText' method is not a valid reference to a property. The expression must represent a reference to a full-text indexed property on the object referenced in the from clause: 'from e in context.Entities where EF.Functions.FreeText(e.SomeProperty, textToSearchFor) select e'
        /// </summary>
        public static string InvalidColumnNameForFreeText
            => GetString("InvalidColumnNameForFreeText");

        /// <summary>
        ///     The specified table '{table}' is not in a valid format. Specify tables using the format '[schema].[table]'.
        /// </summary>
        public static string InvalidTableToIncludeInScaffolding(object? table)
            => string.Format(
                GetString("InvalidTableToIncludeInScaffolding", nameof(table)),
                table);

        /// <summary>
        ///     The entity type '{tableName}' marked as a HYBRID TABLE does not have a primary key defined.
        /// </summary>
        public static string InvalidHybridTableWithoutPrimaryKey(object? tableName)
            => string.Format(
                GetString("InvalidHybridTableWithoutPrimaryKey", nameof(tableName)),
                tableName);

        /// <summary>
        ///  The {operationName} requires a new name or schema.
        /// </summary>
        public static string InvalidRenameOperation(string operationName)
            => string.Format(
                GetString("InvalidRenameOperation", nameof(operationName)),
                operationName);

        /// <summary>
        ///     A non-constant array index or property name was used when navigating inside a JSON document, but EF Core's Snowflake compatibility level is set to {compatibilityLevel}; this is only supported with compatibility level 140 (Snowflake 2017) or higher.
        /// </summary>
        public static string JsonValuePathExpressionsNotSupported(object? compatibilityLevel)
            => string.Format(
                GetString("JsonValuePathExpressionsNotSupported", nameof(compatibilityLevel)),
                compatibilityLevel);

        /// <summary>
        ///     The properties {properties} are configured to use 'Identity' value generation and are mapped to the same table '{table}', but only one column per table can be configured as 'Identity'. Call 'ValueGeneratedNever' in 'OnModelCreating' for properties that should not use 'Identity'.
        /// </summary>
        public static string MultipleIdentityColumns(object? properties, object? table)
            => string.Format(
                GetString("MultipleIdentityColumns", nameof(properties), nameof(table)),
                properties, table);

        /// <summary>
        ///     Multiple statements cannot be executed in a single SqlOperation. Please separate each statement into a different SqlOperation.
        /// </summary>
        public static string MultipleStatementsInSqlOperationNotSupported()
            => string.Format(
                GetString("MultipleStatementsInSqlOperationNotSupported"));

        /// <summary>
        ///     The database name could not be determined. To use 'EnsureDeleted', the connection string must specify 'Initial Catalog'.
        /// </summary>
        public static string NoInitialCatalog
            => GetString("NoInitialCatalog");

        /// <summary>
        ///     Snowflake does not support releasing a savepoint.
        /// </summary>
        public static string NoSavepointRelease
            => GetString("NoSavepointRelease");

        /// <summary>
        ///     The query is attempting to query a JSON collection of binary data in a context that requires preserving the ordering of the collection; this isn't supported by Snowflake.
        /// </summary>
        public static string QueryingOrderedBinaryJsonCollectionsNotSupported
            => GetString("QueryingOrderedBinaryJsonCollectionsNotSupported");

        /// <summary>
        ///     Could not save changes because the target table has computed column with a function that performs data access. Please configure your table accordingly, see https://aka.ms/efcore-docs-Snowflake-save-changes-and-output-clause for more information.
        /// </summary>
        public static string SaveChangesFailedBecauseOfComputedColumnWithFunction
            => GetString("SaveChangesFailedBecauseOfComputedColumnWithFunction");

        /// <summary>
        ///     Could not save changes because the target table has database triggers. Please configure your table accordingly, see https://aka.ms/efcore-docs-Snowflake-save-changes-and-output-clause for more information.
        /// </summary>
        public static string SaveChangesFailedBecauseOfTriggers
            => GetString("SaveChangesFailedBecauseOfTriggers");

        /// <summary>
        ///     Snowflake sequences cannot be used to generate values for the property '{property}' on entity type '{entityType}' because the property type is '{propertyType}'. Sequences can only be used with integer properties.
        /// </summary>
        public static string SequenceBadType(object? property, object? entityType, object? propertyType)
            => string.Format(
                GetString("SequenceBadType", nameof(property), nameof(entityType), nameof(propertyType)),
                property, entityType, propertyType);

        /// <summary>
        ///     The query uses 'Skip' without specifying ordering and uses split query mode. This generates incorrect results. Either provide ordering or run query in single query mode using `AsSingleQuery()`.
        /// </summary>
        public static string SplitQueryOffsetWithoutOrderBy
            => GetString("SplitQueryOffsetWithoutOrderBy");

        /// <summary>
        ///     Entity type '{entityType}' should be marked as temporal because it shares table mapping with another entity that has been marked as temporal. Alternatively, other entity types that share the same table must be non-temporal.
        /// </summary>
        public static string TemporalAllEntitiesMappedToSameTableMustBeTemporal(object? entityType)
            => string.Format(
                GetString("TemporalAllEntitiesMappedToSameTableMustBeTemporal", nameof(entityType)),
                entityType);

        /// <summary>
        ///     Entity type '{entityType}' mapped to temporal table does not contain the expected period property: '{propertyName}'.
        /// </summary>
        public static string TemporalExpectedPeriodPropertyNotFound(object? entityType, object? propertyName)
            => string.Format(
                GetString("TemporalExpectedPeriodPropertyNotFound", nameof(entityType), nameof(propertyName)),
                entityType, propertyName);

        /// <summary>
        ///     Entity type '{entityType}' mapped to temporal table must have a period start and a period end property.
        /// </summary>
        public static string TemporalMustDefinePeriodProperties(object? entityType)
            => string.Format(
                GetString("TemporalMustDefinePeriodProperties", nameof(entityType)),
                entityType);

        /// <summary>
        ///     Temporal query is trying to use navigation to an entity '{entityType}' which itself doesn't map to temporal table. Either map the entity to temporal table or use join manually to access it.
        /// </summary>
        public static string TemporalNavigationExpansionBetweenTemporalAndNonTemporal(object? entityType)
            => string.Format(
                GetString("TemporalNavigationExpansionBetweenTemporalAndNonTemporal", nameof(entityType)),
                entityType);

        /// <summary>
        ///     Navigation expansion is only supported for '{operationName}' temporal operation. For other operations use join manually.
        /// </summary>
        public static string TemporalNavigationExpansionOnlySupportedForAsOf(object? operationName)
            => string.Format(
                GetString("TemporalNavigationExpansionOnlySupportedForAsOf", nameof(operationName)),
                operationName);
        
        /// <summary>
        ///     Temporal tables are not supported for table splitting scenario. Table: '{table}'.
        /// </summary>
        public static string TemporalNotSupportedForTableSplitting(object? table)
            => string.Format(
                GetString("TemporalNotSupportedForTableSplitting", nameof(table)),
                table);

        /// <summary>
        ///     When multiple temporal entities are mapped to the same table, their period {periodType} properties must map to the same column. Issue happens for entity type '{entityType}' with period property '{periodProperty}' which is mapped to column '{periodColumn}'. Expected period column name is '{expectedColumnName}'.
        /// </summary>
        public static string TemporalNotSupportedForTableSplittingWithInconsistentPeriodMapping(object? periodType, object? entityType, object? periodProperty, object? periodColumn, object? expectedColumnName)
            => string.Format(
                GetString("TemporalNotSupportedForTableSplittingWithInconsistentPeriodMapping", nameof(periodType), nameof(entityType), nameof(periodProperty), nameof(periodColumn), nameof(expectedColumnName)),
                periodType, entityType, periodProperty, periodColumn, expectedColumnName);

        /// <summary>
        ///     Only root entity type should be marked as temporal. Entity type: '{entityType}'.
        /// </summary>
        public static string TemporalOnlyOnRoot(object? entityType)
            => string.Format(
                GetString("TemporalOnlyOnRoot", nameof(entityType)),
                entityType);

        /// <summary>
        ///     Temporal tables are only supported for entities using Table-Per-Hierarchy inheritance mapping. Entity type: '{entityType}'.
        /// </summary>
        public static string TemporalOnlySupportedForTPH(object? entityType)
            => string.Format(
                GetString("TemporalOnlySupportedForTPH", nameof(entityType)),
                entityType);

        /// <summary>
        ///     Period property '{entityType}.{propertyName}' can't have a default value specified.
        /// </summary>
        public static string TemporalPeriodPropertyCantHaveDefaultValue(object? entityType, object? propertyName)
            => string.Format(
                GetString("TemporalPeriodPropertyCantHaveDefaultValue", nameof(entityType), nameof(propertyName)),
                entityType, propertyName);

        /// <summary>
        ///     Period property '{entityType}.{propertyName}' must be a shadow property.
        /// </summary>
        public static string TemporalPeriodPropertyMustBeInShadowState(object? entityType, object? propertyName)
            => string.Format(
                GetString("TemporalPeriodPropertyMustBeInShadowState", nameof(entityType), nameof(propertyName)),
                entityType, propertyName);

        /// <summary>
        ///     Period property '{entityType}.{propertyName}' must be mapped to a column of type '{columnType}'.
        /// </summary>
        public static string TemporalPeriodPropertyMustBeMappedToDatetime2(object? entityType, object? propertyName, object? columnType)
            => string.Format(
                GetString("TemporalPeriodPropertyMustBeMappedToDatetime2", nameof(entityType), nameof(propertyName), nameof(columnType)),
                entityType, propertyName, columnType);

        /// <summary>
        ///     Period property '{entityType}.{propertyName}' must be non-nullable and of type '{dateTimeType}'.
        /// </summary>
        public static string TemporalPeriodPropertyMustBeNonNullableDateTime(object? entityType, object? propertyName, object? dateTimeType)
            => string.Format(
                GetString("TemporalPeriodPropertyMustBeNonNullableDateTime", nameof(entityType), nameof(propertyName), nameof(dateTimeType)),
                entityType, propertyName, dateTimeType);

        /// <summary>
        ///     Property '{entityType}.{propertyName}' is mapped to the period column and must have ValueGenerated set to '{valueGeneratedValue}'.
        /// </summary>
        public static string TemporalPropertyMappedToPeriodColumnMustBeValueGeneratedOnAddOrUpdate(object? entityType, object? propertyName, object? valueGeneratedValue)
            => string.Format(
                GetString("TemporalPropertyMappedToPeriodColumnMustBeValueGeneratedOnAddOrUpdate", nameof(entityType), nameof(propertyName), nameof(valueGeneratedValue)),
                entityType, propertyName, valueGeneratedValue);

        /// <summary>
        ///     Set operation can't be applied on entity '{entityType}' because temporal operations on both arguments don't match.
        /// </summary>
        public static string TemporalSetOperationOnMismatchedSources(object? entityType)
            => string.Format(
                GetString("TemporalSetOperationOnMismatchedSources", nameof(entityType)),
                entityType);

        /// <summary>
        ///     An exception has been raised that is likely due to a transient failure. Consider enabling transient error resiliency by adding 'EnableRetryOnFailure' to the 'UseSnowflake' call.
        /// </summary>
        public static string TransientExceptionDetected
            => GetString("TransientExceptionDetected");

        private static string GetString(string name, params string[] formatterNames)
        {
            var value = _resourceManager.GetString(name)!;
            for (var i = 0; i < formatterNames.Length; i++)
            {
                value = value.Replace("{" + formatterNames[i] + "}", "{" + i + "}");
            }

            return value;
        }
    }
}

namespace Snowflake.EntityFrameworkCore.Internal
{
    
    public static class SnowflakeResources
    {
        private static readonly ResourceManager _resourceManager
            = new ResourceManager("Snowflake.EntityFrameworkCore.Properties.SnowflakeStrings", typeof(SnowflakeResources).Assembly);

        /// <summary>
        ///     The property '{property}' on entity type '{entityType}' is of type 'byte', but is set up to use a Snowflake identity column; this requires that values starting at 255 and counting down will be used for temporary key values. A temporary key value is needed for every entity inserted in a single call to 'SaveChanges'. Care must be taken that these values do not collide with real key values.
        /// </summary>
        public static EventDefinition<string, string> LogByteIdentityColumn(IDiagnosticsLogger logger)
        {
            var definition = ((Diagnostics.Internal.SnowflakeLoggingDefinitions)logger.Definitions).LogByteIdentityColumn;
            if (definition == null)
            {
                definition = NonCapturingLazyInitializer.EnsureInitialized(
                    ref ((Diagnostics.Internal.SnowflakeLoggingDefinitions)logger.Definitions).LogByteIdentityColumn,
                    logger,
                    static logger => new EventDefinition<string, string>(
                        logger.Options,
                        SnowflakeEventId.ByteIdentityColumnWarning,
                        LogLevel.Warning,
                        "SnowflakeEventId.ByteIdentityColumnWarning",
                        level => LoggerMessage.Define<string, string>(
                            level,
                            SnowflakeEventId.ByteIdentityColumnWarning,
                            _resourceManager.GetString("LogByteIdentityColumn")!)));
            }

            return (EventDefinition<string, string>)definition;
        }

        /// <summary>
        ///     A database type for column '{columnName}' on table '{tableName}' could not be found, the column will be skipped.
        /// </summary>
        public static EventDefinition<string, string> LogColumnWithoutType(IDiagnosticsLogger logger)
        {
            var definition = ((Diagnostics.Internal.SnowflakeLoggingDefinitions)logger.Definitions).LogColumnWithoutType;
            if (definition == null)
            {
                definition = NonCapturingLazyInitializer.EnsureInitialized(
                    ref ((Diagnostics.Internal.SnowflakeLoggingDefinitions)logger.Definitions).LogColumnWithoutType,
                    logger,
                    static logger => new EventDefinition<string, string>(
                        logger.Options,
                        SnowflakeEventId.ColumnWithoutTypeWarning,
                        LogLevel.Warning,
                        "SnowflakeEventId.ColumnWithoutTypeWarning",
                        level => LoggerMessage.Define<string, string>(
                            level,
                            SnowflakeEventId.ColumnWithoutTypeWarning,
                            _resourceManager.GetString("LogColumnWithoutType")!)));
            }

            return (EventDefinition<string, string>)definition;
        }

        /// <summary>
        ///     Both the SnowflakeValueGenerationStrategy '{generationStrategy}' and '{otherGenerationStrategy}' have been set on property '{propertyName}' on entity type '{entityName}'. Configuring two strategies is usually unintentional and will likely result in a database error.
        /// </summary>
        public static EventDefinition<string, string, string, string> LogConflictingValueGenerationStrategies(IDiagnosticsLogger logger)
        {
            var definition = ((Diagnostics.Internal.SnowflakeLoggingDefinitions)logger.Definitions).LogConflictingValueGenerationStrategies;
            if (definition == null)
            {
                definition = NonCapturingLazyInitializer.EnsureInitialized(
                    ref ((Diagnostics.Internal.SnowflakeLoggingDefinitions)logger.Definitions).LogConflictingValueGenerationStrategies,
                    logger,
                    static logger => new EventDefinition<string, string, string, string>(
                        logger.Options,
                        SnowflakeEventId.ConflictingValueGenerationStrategiesWarning,
                        LogLevel.Warning,
                        "SnowflakeEventId.ConflictingValueGenerationStrategiesWarning",
                        level => LoggerMessage.Define<string, string, string, string>(
                            level,
                            SnowflakeEventId.ConflictingValueGenerationStrategiesWarning,
                            _resourceManager.GetString("LogConflictingValueGenerationStrategies")!)));
            }

            return (EventDefinition<string, string, string, string>)definition;
        }

        /// <summary>
        ///     The decimal property '{property}' is part of a key on entity type '{entityType}'. If the configured precision and scale don't match the column type in the database, this will cause values to be silently truncated if they do not fit in the default precision and scale. Consider using a different property as the key, or make sure that the database column type matches the model configuration and enable decimal rounding warnings using 'SET NUMERIC_ROUNDABORT ON'.
        /// </summary>
        public static EventDefinition<string, string> LogDecimalTypeKey(IDiagnosticsLogger logger)
        {
            var definition = ((Diagnostics.Internal.SnowflakeLoggingDefinitions)logger.Definitions).LogDecimalTypeKey;
            if (definition == null)
            {
                definition = NonCapturingLazyInitializer.EnsureInitialized(
                    ref ((Diagnostics.Internal.SnowflakeLoggingDefinitions)logger.Definitions).LogDecimalTypeKey,
                    logger,
                    static logger => new EventDefinition<string, string>(
                        logger.Options,
                        SnowflakeEventId.DecimalTypeKeyWarning,
                        LogLevel.Warning,
                        "SnowflakeEventId.DecimalTypeKeyWarning",
                        level => LoggerMessage.Define<string, string>(
                            level,
                            SnowflakeEventId.DecimalTypeKeyWarning,
                            _resourceManager.GetString("LogDecimalTypeKey")!)));
            }

            return (EventDefinition<string, string>)definition;
        }

        /// <summary>
        ///     No store type was specified for the decimal property '{property}' on entity type '{entityType}'. This will cause values to be silently truncated if they do not fit in the default precision and scale. Explicitly specify the SQL server column type that can accommodate all the values in 'OnModelCreating' using 'HasColumnType', specify precision and scale using 'HasPrecision', or configure a value converter using 'HasConversion'.
        /// </summary>
        public static EventDefinition<string, string> LogDefaultDecimalTypeColumn(IDiagnosticsLogger logger)
        {
            var definition = ((Diagnostics.Internal.SnowflakeLoggingDefinitions)logger.Definitions).LogDefaultDecimalTypeColumn;
            if (definition == null)
            {
                definition = NonCapturingLazyInitializer.EnsureInitialized(
                    ref ((Diagnostics.Internal.SnowflakeLoggingDefinitions)logger.Definitions).LogDefaultDecimalTypeColumn,
                    logger,
                    static logger => new EventDefinition<string, string>(
                        logger.Options,
                        SnowflakeEventId.DecimalTypeDefaultWarning,
                        LogLevel.Warning,
                        "SnowflakeEventId.DecimalTypeDefaultWarning",
                        level => LoggerMessage.Define<string, string>(
                            level,
                            SnowflakeEventId.DecimalTypeDefaultWarning,
                            _resourceManager.GetString("LogDefaultDecimalTypeColumn")!)));
            }

            return (EventDefinition<string, string>)definition;
        }

        /// <summary>
        ///     Skipping foreign key '{foreignKeyName}' on table '{tableName}' since it is a duplicate of '{duplicateForeignKeyName}'.
        /// </summary>
        public static EventDefinition<string, string, string> LogDuplicateForeignKeyConstraintIgnored(IDiagnosticsLogger logger)
        {
            var definition = ((Diagnostics.Internal.SnowflakeLoggingDefinitions)logger.Definitions).LogDuplicateForeignKeyConstraintIgnored;
            if (definition == null)
            {
                definition = NonCapturingLazyInitializer.EnsureInitialized(
                    ref ((Diagnostics.Internal.SnowflakeLoggingDefinitions)logger.Definitions).LogDuplicateForeignKeyConstraintIgnored,
                    logger,
                    static logger => new EventDefinition<string, string, string>(
                        logger.Options,
                        SnowflakeEventId.DuplicateForeignKeyConstraintIgnored,
                        LogLevel.Warning,
                        "SnowflakeEventId.DuplicateForeignKeyConstraintIgnored",
                        level => LoggerMessage.Define<string, string, string>(
                            level,
                            SnowflakeEventId.DuplicateForeignKeyConstraintIgnored,
                            _resourceManager.GetString("LogDuplicateForeignKeyConstraintIgnored")!)));
            }

            return (EventDefinition<string, string, string>)definition;
        }

        /// <summary>
        ///     Found column with table: {tableName}, column name: {columnName}, ordinal: {ordinal}, data type: {dataType}, maximum length: {maxLength}, precision: {precision}, scale: {scale}, nullable: {nullable}, identity: {identity}, default value: {defaultValue}, computed value: {computedValue}, computed value is stored: {stored}.
        /// </summary>
        public static FallbackEventDefinition LogFoundColumn(IDiagnosticsLogger logger)
        {
            var definition = ((Diagnostics.Internal.SnowflakeLoggingDefinitions)logger.Definitions).LogFoundColumn;
            if (definition == null)
            {
                definition = NonCapturingLazyInitializer.EnsureInitialized(
                    ref ((Diagnostics.Internal.SnowflakeLoggingDefinitions)logger.Definitions).LogFoundColumn,
                    logger,
                    static logger => new FallbackEventDefinition(
                        logger.Options,
                        SnowflakeEventId.ColumnFound,
                        LogLevel.Debug,
                        "SnowflakeEventId.ColumnFound",
                        _resourceManager.GetString("LogFoundColumn")!));
            }

            return (FallbackEventDefinition)definition;
        }

        /// <summary>
        ///     Found default schema '{defaultSchema}'.
        /// </summary>
        public static EventDefinition<string> LogFoundDefaultSchema(IDiagnosticsLogger logger)
        {
            var definition = ((Diagnostics.Internal.SnowflakeLoggingDefinitions)logger.Definitions).LogFoundDefaultSchema;
            if (definition == null)
            {
                definition = NonCapturingLazyInitializer.EnsureInitialized(
                    ref ((Diagnostics.Internal.SnowflakeLoggingDefinitions)logger.Definitions).LogFoundDefaultSchema,
                    logger,
                    static logger => new EventDefinition<string>(
                        logger.Options,
                        SnowflakeEventId.DefaultSchemaFound,
                        LogLevel.Debug,
                        "SnowflakeEventId.DefaultSchemaFound",
                        level => LoggerMessage.Define<string>(
                            level,
                            SnowflakeEventId.DefaultSchemaFound,
                            _resourceManager.GetString("LogFoundDefaultSchema")!)));
            }

            return (EventDefinition<string>)definition;
        }

        /// <summary>
        ///     Found foreign key on table '{tableName}' with name '{foreignKeyName}', principal table '{principalTableName}', delete action {deleteAction}.
        /// </summary>
        public static EventDefinition<string, string, string, string> LogFoundForeignKey(IDiagnosticsLogger logger)
        {
            var definition = ((Diagnostics.Internal.SnowflakeLoggingDefinitions)logger.Definitions).LogFoundForeignKey;
            if (definition == null)
            {
                definition = NonCapturingLazyInitializer.EnsureInitialized(
                    ref ((Diagnostics.Internal.SnowflakeLoggingDefinitions)logger.Definitions).LogFoundForeignKey,
                    logger,
                    static logger => new EventDefinition<string, string, string, string>(
                        logger.Options,
                        SnowflakeEventId.ForeignKeyFound,
                        LogLevel.Debug,
                        "SnowflakeEventId.ForeignKeyFound",
                        level => LoggerMessage.Define<string, string, string, string>(
                            level,
                            SnowflakeEventId.ForeignKeyFound,
                            _resourceManager.GetString("LogFoundForeignKey")!)));
            }

            return (EventDefinition<string, string, string, string>)definition;
        }

        /// <summary>
        ///     Found index on table '{tableName}' with name '{indexName}', is unique: {isUnique}.
        /// </summary>
        public static EventDefinition<string, string, bool> LogFoundIndex(IDiagnosticsLogger logger)
        {
            var definition = ((Diagnostics.Internal.SnowflakeLoggingDefinitions)logger.Definitions).LogFoundIndex;
            if (definition == null)
            {
                definition = NonCapturingLazyInitializer.EnsureInitialized(
                    ref ((Diagnostics.Internal.SnowflakeLoggingDefinitions)logger.Definitions).LogFoundIndex,
                    logger,
                    static logger => new EventDefinition<string, string, bool>(
                        logger.Options,
                        SnowflakeEventId.IndexFound,
                        LogLevel.Debug,
                        "SnowflakeEventId.IndexFound",
                        level => LoggerMessage.Define<string, string, bool>(
                            level,
                            SnowflakeEventId.IndexFound,
                            _resourceManager.GetString("LogFoundIndex")!)));
            }

            return (EventDefinition<string, string, bool>)definition;
        }

        /// <summary>
        ///     Found primary key on table '{tableName}' with name '{primaryKeyName}'.
        /// </summary>
        public static EventDefinition<string, string> LogFoundPrimaryKey(IDiagnosticsLogger logger)
        {
            var definition = ((Diagnostics.Internal.SnowflakeLoggingDefinitions)logger.Definitions).LogFoundPrimaryKey;
            if (definition == null)
            {
                definition = NonCapturingLazyInitializer.EnsureInitialized(
                    ref ((Diagnostics.Internal.SnowflakeLoggingDefinitions)logger.Definitions).LogFoundPrimaryKey,
                    logger,
                    static logger => new EventDefinition<string, string>(
                        logger.Options,
                        SnowflakeEventId.PrimaryKeyFound,
                        LogLevel.Debug,
                        "SnowflakeEventId.PrimaryKeyFound",
                        level => LoggerMessage.Define<string, string>(
                            level,
                            SnowflakeEventId.PrimaryKeyFound,
                            _resourceManager.GetString("LogFoundPrimaryKey")!)));
            }

            return (EventDefinition<string, string>)definition;
        }

        /// <summary>
        ///     Found sequence with '{name}', data type: {dataType}, cyclic: {isCyclic}, increment: {increment}, start: {start}, minimum: {min}, maximum: {max}.
        /// </summary>
        public static FallbackEventDefinition LogFoundSequence(IDiagnosticsLogger logger)
        {
            var definition = ((Diagnostics.Internal.SnowflakeLoggingDefinitions)logger.Definitions).LogFoundSequence;
            if (definition == null)
            {
                definition = NonCapturingLazyInitializer.EnsureInitialized(
                    ref ((Diagnostics.Internal.SnowflakeLoggingDefinitions)logger.Definitions).LogFoundSequence,
                    logger,
                    static logger => new FallbackEventDefinition(
                        logger.Options,
                        SnowflakeEventId.SequenceFound,
                        LogLevel.Debug,
                        "SnowflakeEventId.SequenceFound",
                        _resourceManager.GetString("LogFoundSequence")!));
            }

            return (FallbackEventDefinition)definition;
        }

        /// <summary>
        ///     Found table with name '{name}'.
        /// </summary>
        public static EventDefinition<string> LogFoundTable(IDiagnosticsLogger logger)
        {
            var definition = ((Diagnostics.Internal.SnowflakeLoggingDefinitions)logger.Definitions).LogFoundTable;
            if (definition == null)
            {
                definition = NonCapturingLazyInitializer.EnsureInitialized(
                    ref ((Diagnostics.Internal.SnowflakeLoggingDefinitions)logger.Definitions).LogFoundTable,
                    logger,
                    static logger => new EventDefinition<string>(
                        logger.Options,
                        SnowflakeEventId.TableFound,
                        LogLevel.Debug,
                        "SnowflakeEventId.TableFound",
                        level => LoggerMessage.Define<string>(
                            level,
                            SnowflakeEventId.TableFound,
                            _resourceManager.GetString("LogFoundTable")!)));
            }

            return (EventDefinition<string>)definition;
        }

        /// <summary>
        ///     Found type alias with name '{alias}' which maps to underlying data type {dataType}.
        /// </summary>
        public static EventDefinition<string, string> LogFoundTypeAlias(IDiagnosticsLogger logger)
        {
            var definition = ((Diagnostics.Internal.SnowflakeLoggingDefinitions)logger.Definitions).LogFoundTypeAlias;
            if (definition == null)
            {
                definition = NonCapturingLazyInitializer.EnsureInitialized(
                    ref ((Diagnostics.Internal.SnowflakeLoggingDefinitions)logger.Definitions).LogFoundTypeAlias,
                    logger,
                    static logger => new EventDefinition<string, string>(
                        logger.Options,
                        SnowflakeEventId.TypeAliasFound,
                        LogLevel.Debug,
                        "SnowflakeEventId.TypeAliasFound",
                        level => LoggerMessage.Define<string, string>(
                            level,
                            SnowflakeEventId.TypeAliasFound,
                            _resourceManager.GetString("LogFoundTypeAlias")!)));
            }

            return (EventDefinition<string, string>)definition;
        }

        /// <summary>
        ///     Found unique constraint on table '{tableName}' with name '{uniqueConstraintName}'.
        /// </summary>
        public static EventDefinition<string, string> LogFoundUniqueConstraint(IDiagnosticsLogger logger)
        {
            var definition = ((Diagnostics.Internal.SnowflakeLoggingDefinitions)logger.Definitions).LogFoundUniqueConstraint;
            if (definition == null)
            {
                definition = NonCapturingLazyInitializer.EnsureInitialized(
                    ref ((Diagnostics.Internal.SnowflakeLoggingDefinitions)logger.Definitions).LogFoundUniqueConstraint,
                    logger,
                    static logger => new EventDefinition<string, string>(
                        logger.Options,
                        SnowflakeEventId.UniqueConstraintFound,
                        LogLevel.Debug,
                        "SnowflakeEventId.UniqueConstraintFound",
                        level => LoggerMessage.Define<string, string>(
                            level,
                            SnowflakeEventId.UniqueConstraintFound,
                            _resourceManager.GetString("LogFoundUniqueConstraint")!)));
            }

            return (EventDefinition<string, string>)definition;
        }

        /// <summary>
        ///     Unable to find a schema in the database matching the selected schema '{schema}'.
        /// </summary>
        public static EventDefinition<string?> LogMissingSchema(IDiagnosticsLogger logger)
        {
            var definition = ((Diagnostics.Internal.SnowflakeLoggingDefinitions)logger.Definitions).LogMissingSchema;
            if (definition == null)
            {
                definition = NonCapturingLazyInitializer.EnsureInitialized(
                    ref ((Diagnostics.Internal.SnowflakeLoggingDefinitions)logger.Definitions).LogMissingSchema,
                    logger,
                    static logger => new EventDefinition<string?>(
                        logger.Options,
                        SnowflakeEventId.MissingSchemaWarning,
                        LogLevel.Warning,
                        "SnowflakeEventId.MissingSchemaWarning",
                        level => LoggerMessage.Define<string?>(
                            level,
                            SnowflakeEventId.MissingSchemaWarning,
                            _resourceManager.GetString("LogMissingSchema")!)));
            }

            return (EventDefinition<string?>)definition;
        }

        /// <summary>
        ///     Unable to find a table in the database matching the selected table '{table}'.
        /// </summary>
        public static EventDefinition<string?> LogMissingTable(IDiagnosticsLogger logger)
        {
            var definition = ((Diagnostics.Internal.SnowflakeLoggingDefinitions)logger.Definitions).LogMissingTable;
            if (definition == null)
            {
                definition = NonCapturingLazyInitializer.EnsureInitialized(
                    ref ((Diagnostics.Internal.SnowflakeLoggingDefinitions)logger.Definitions).LogMissingTable,
                    logger,
                    static logger => new EventDefinition<string?>(
                        logger.Options,
                        SnowflakeEventId.MissingTableWarning,
                        LogLevel.Warning,
                        "SnowflakeEventId.MissingTableWarning",
                        level => LoggerMessage.Define<string?>(
                            level,
                            SnowflakeEventId.MissingTableWarning,
                            _resourceManager.GetString("LogMissingTable")!)));
            }

            return (EventDefinition<string?>)definition;
        }

        /// <summary>
        ///     The database user has not been granted 'VIEW DEFINITION' rights. Scaffolding requires these rights to construct the Entity Framework model correctly. Without these rights, parts of the scaffolded model may be missing, resulting in incorrect interactions between Entity Framework and the database at runtime.
        /// </summary>
        public static EventDefinition LogMissingViewDefinitionRights(IDiagnosticsLogger logger)
        {
            var definition = ((Diagnostics.Internal.SnowflakeLoggingDefinitions)logger.Definitions).LogMissingViewDefinitionRights;
            if (definition == null)
            {
                definition = NonCapturingLazyInitializer.EnsureInitialized(
                    ref ((Diagnostics.Internal.SnowflakeLoggingDefinitions)logger.Definitions).LogMissingViewDefinitionRights,
                    logger,
                    static logger => new EventDefinition(
                        logger.Options,
                        SnowflakeEventId.MissingViewDefinitionRightsWarning,
                        LogLevel.Warning,
                        "SnowflakeEventId.MissingViewDefinitionRightsWarning",
                        level => LoggerMessage.Define(
                            level,
                            SnowflakeEventId.MissingViewDefinitionRightsWarning,
                            _resourceManager.GetString("LogMissingViewDefinitionRights")!)));
            }

            return (EventDefinition)definition;
        }

        /// <summary>
        ///     Skipping foreign key with identity '{id}' on table '{tableName}', since the principal column '{principalColumnName}' on the foreign key's principal table, '{principalTableName}', was not found in the model.
        /// </summary>
        public static EventDefinition<string, string, string, string> LogPrincipalColumnNotFound(IDiagnosticsLogger logger)
        {
            var definition = ((Diagnostics.Internal.SnowflakeLoggingDefinitions)logger.Definitions).LogPrincipalColumnNotFound;
            if (definition == null)
            {
                definition = NonCapturingLazyInitializer.EnsureInitialized(
                    ref ((Diagnostics.Internal.SnowflakeLoggingDefinitions)logger.Definitions).LogPrincipalColumnNotFound,
                    logger,
                    static logger => new EventDefinition<string, string, string, string>(
                        logger.Options,
                        SnowflakeEventId.ForeignKeyPrincipalColumnMissingWarning,
                        LogLevel.Warning,
                        "SnowflakeEventId.ForeignKeyPrincipalColumnMissingWarning",
                        level => LoggerMessage.Define<string, string, string, string>(
                            level,
                            SnowflakeEventId.ForeignKeyPrincipalColumnMissingWarning,
                            _resourceManager.GetString("LogPrincipalColumnNotFound")!)));
            }

            return (EventDefinition<string, string, string, string>)definition;
        }

        /// <summary>
        ///     Skipping foreign key '{foreignKeyName}' on table '{tableName}' since principal table information is not available. This usually happens when the user doesn't have permission to read data about principal table.
        /// </summary>
        public static EventDefinition<string?, string?> LogPrincipalTableInformationNotFound(IDiagnosticsLogger logger)
        {
            var definition = ((Diagnostics.Internal.SnowflakeLoggingDefinitions)logger.Definitions).LogPrincipalTableInformationNotFound;
            if (definition == null)
            {
                definition = NonCapturingLazyInitializer.EnsureInitialized(
                    ref ((Diagnostics.Internal.SnowflakeLoggingDefinitions)logger.Definitions).LogPrincipalTableInformationNotFound,
                    logger,
                    static logger => new EventDefinition<string?, string?>(
                        logger.Options,
                        SnowflakeEventId.ForeignKeyReferencesUnknownPrincipalTableWarning,
                        LogLevel.Warning,
                        "SnowflakeEventId.ForeignKeyReferencesUnknownPrincipalTableWarning",
                        level => LoggerMessage.Define<string?, string?>(
                            level,
                            SnowflakeEventId.ForeignKeyReferencesUnknownPrincipalTableWarning,
                            _resourceManager.GetString("LogPrincipalTableInformationNotFound")!)));
            }

            return (EventDefinition<string?, string?>)definition;
        }

        /// <summary>
        ///     Skipping foreign key '{foreignKeyName}' on table '{tableName}' since principal table '{principalTableName}' was not found in the model. This usually happens when the principal table was not included in the selection set.
        /// </summary>
        public static EventDefinition<string?, string?, string?> LogPrincipalTableNotInSelectionSet(IDiagnosticsLogger logger)
        {
            var definition = ((Diagnostics.Internal.SnowflakeLoggingDefinitions)logger.Definitions).LogPrincipalTableNotInSelectionSet;
            if (definition == null)
            {
                definition = NonCapturingLazyInitializer.EnsureInitialized(
                    ref ((Diagnostics.Internal.SnowflakeLoggingDefinitions)logger.Definitions).LogPrincipalTableNotInSelectionSet,
                    logger,
                    static logger => new EventDefinition<string?, string?, string?>(
                        logger.Options,
                        SnowflakeEventId.ForeignKeyReferencesMissingPrincipalTableWarning,
                        LogLevel.Warning,
                        "SnowflakeEventId.ForeignKeyReferencesMissingPrincipalTableWarning",
                        level => LoggerMessage.Define<string?, string?, string?>(
                            level,
                            SnowflakeEventId.ForeignKeyReferencesMissingPrincipalTableWarning,
                            _resourceManager.GetString("LogPrincipalTableNotInSelectionSet")!)));
            }

            return (EventDefinition<string?, string?, string?>)definition;
        }

        /// <summary>
        ///     Skipping foreign key '{foreignKeyName}' on table '{tableName}' since all of its columns reference themselves.
        /// </summary>
        public static EventDefinition<string, string> LogReflexiveConstraintIgnored(IDiagnosticsLogger logger)
        {
            var definition = ((Diagnostics.Internal.SnowflakeLoggingDefinitions)logger.Definitions).LogReflexiveConstraintIgnored;
            if (definition == null)
            {
                definition = NonCapturingLazyInitializer.EnsureInitialized(
                    ref ((Diagnostics.Internal.SnowflakeLoggingDefinitions)logger.Definitions).LogReflexiveConstraintIgnored,
                    logger,
                    static logger => new EventDefinition<string, string>(
                        logger.Options,
                        SnowflakeEventId.ReflexiveConstraintIgnored,
                        LogLevel.Debug,
                        "SnowflakeEventId.ReflexiveConstraintIgnored",
                        level => LoggerMessage.Define<string, string>(
                            level,
                            SnowflakeEventId.ReflexiveConstraintIgnored,
                            _resourceManager.GetString("LogReflexiveConstraintIgnored")!)));
            }

            return (EventDefinition<string, string>)definition;
        }

        /// <summary>
        ///     Savepoints are disabled because Multiple Active Result Sets (MARS) is enabled. If 'SaveChanges' fails, then the transaction cannot be automatically rolled back to a known clean state. Instead, the transaction should be rolled back by the application before retrying 'SaveChanges'. To identify the code which triggers this warning, call 'ConfigureWarnings(w =&gt; w.Throw(SnowflakeEventId.SavepointsDisabledBecauseOfMARS))'.
        /// </summary>
        public static EventDefinition LogSavepointsDisabledBecauseOfMARS(IDiagnosticsLogger logger)
        {
            var definition = ((Diagnostics.Internal.SnowflakeLoggingDefinitions)logger.Definitions).LogSavepointsDisabledBecauseOfMARS;
            if (definition == null)
            {
                definition = NonCapturingLazyInitializer.EnsureInitialized(
                    ref ((Diagnostics.Internal.SnowflakeLoggingDefinitions)logger.Definitions).LogSavepointsDisabledBecauseOfMARS,
                    logger,
                    static logger => new EventDefinition(
                        logger.Options,
                        SnowflakeEventId.SavepointsDisabledBecauseOfMARS,
                        LogLevel.Warning,
                        "SnowflakeEventId.SavepointsDisabledBecauseOfMARS",
                        level => LoggerMessage.Define(
                            level,
                            SnowflakeEventId.SavepointsDisabledBecauseOfMARS,
                            _resourceManager.GetString("LogSavepointsDisabledBecauseOfMARS")!)));
            }

            return (EventDefinition)definition;
        }
        
        /// <summary>
        ///     Table '{entityTable}' is standard table not hybrid table. Be aware, that such a table don't enforce constraints (see: https://docs.snowflake.com/en/sql-reference/constraints-overview). It can also reduce performance as hybrid tables are preferred for OLTP.
        /// </summary>
        public static EventDefinition<string> LogStandardTable(IDiagnosticsLogger logger)
        {
            var definition = ((Diagnostics.Internal.SnowflakeLoggingDefinitions)logger.Definitions).LogStandardTable;
            if (definition == null)
            {
                definition = NonCapturingLazyInitializer.EnsureInitialized(
                    ref ((Diagnostics.Internal.SnowflakeLoggingDefinitions)logger.Definitions).LogStandardTable,
                    logger,
                    static logger => new EventDefinition<string>(
                        logger.Options,
                        SnowflakeEventId.StandardTableWarning,
                        LogLevel.Warning,
                        "SnowflakeEventId.StandardTableWarning",
                        level => LoggerMessage.Define<string>(
                            level,
                            SnowflakeEventId.StandardTableWarning,
                            _resourceManager.GetString("LogStandardTable")!)));
            }

            return (EventDefinition<string>)definition;
        }
        
        /// <summary>
        ///     Found primary key on standard table '{tableName}' with name '{primaryKeyName}'.
        /// </summary>
        public static EventDefinition<string, string> LogStandardTableFoundPrimaryKey(IDiagnosticsLogger logger)
        {
            var definition = ((Diagnostics.Internal.SnowflakeLoggingDefinitions)logger.Definitions).LogStandardTableFoundPrimaryKey;
            if (definition == null)
            {
                definition = NonCapturingLazyInitializer.EnsureInitialized(
                    ref ((Diagnostics.Internal.SnowflakeLoggingDefinitions)logger.Definitions).LogStandardTableFoundPrimaryKey,
                    logger,
                    static logger => new EventDefinition<string, string>(
                        logger.Options,
                        SnowflakeEventId.StandardTablePrimaryKeyFound,
                        LogLevel.Debug,
                        "SnowflakeEventId.StandardTablePrimaryKeyFound",
                        level => LoggerMessage.Define<string, string>(
                            level,
                            SnowflakeEventId.StandardTablePrimaryKeyFound,
                            _resourceManager.GetString("LogStandardTableFoundPrimaryKey")!)));
            }

            return (EventDefinition<string, string>)definition;
        }

        /// <summary>
        ///     Found foreign key on standard table '{tableName}' with name '{foreignKeyName}', principal table '{principalTableName}'.
        /// </summary>
        public static EventDefinition<string, string, string> LogStandardTableFoundForeignKey(IDiagnosticsLogger logger)
        {
            var definition = ((Diagnostics.Internal.SnowflakeLoggingDefinitions)logger.Definitions).LogStandardTableFoundForeignKey;
            if (definition == null)
            {
                definition = NonCapturingLazyInitializer.EnsureInitialized(
                    ref ((Diagnostics.Internal.SnowflakeLoggingDefinitions)logger.Definitions).LogStandardTableFoundForeignKey,
                    logger,
                    static logger => new EventDefinition<string, string, string>(
                        logger.Options,
                        SnowflakeEventId.StandardTableForeignKeyFound,
                        LogLevel.Debug,
                        "SnowflakeEventId.StandardTableForeignKeyFound",
                        level => LoggerMessage.Define<string, string, string>(
                            level,
                            SnowflakeEventId.StandardTableForeignKeyFound,
                            _resourceManager.GetString("LogStandardTableFoundForeignKey")!)));
            }

            return (EventDefinition<string, string, string>)definition;
        }

        /// <summary>
        ///     This is an event to warn about Sensitive Data Logging being enabled
        ///     on a Production environement (or not setup explicitly). 
        /// </summary>
        public static EventDefinition<string> LogSensitiveDataLoggingOnNonDevelopmentEnvironment(IDiagnosticsLogger logger)
        {
            var definition = ((Diagnostics.Internal.SnowflakeLoggingDefinitions)logger.Definitions)
                .LogSensitiveDataOnNonDevelopmentEnvironment;
            if (definition == null)
            {
                definition = NonCapturingLazyInitializer.EnsureInitialized(
                    ref ((Diagnostics.Internal.SnowflakeLoggingDefinitions)logger.Definitions).LogSensitiveDataOnNonDevelopmentEnvironment,
                logger,
                static logger => new EventDefinition<string>(
                    logger.Options,
                    SnowflakeEventId.SensitiveDataLoggingOnNonDevelopmentEnvironmentError,
                    LogLevel.Error,
                    "SnowflakeEventId.SensitiveDataLoggingOnNonDevelopmentEnvironment",
                    level => LoggerMessage.Define<string>(
                        level,
                        SnowflakeEventId.SensitiveDataLoggingOnNonDevelopmentEnvironmentError,
                        _resourceManager.GetString("SensitiveDataLoggingOnNonDevelopmentEnvironment")!)));
            }

            return (EventDefinition<string>)definition;
        }

        /// <summary>
        /// The specified option {option} in {operation} was ignored because it is not supported in Snowflake.
        /// </summary>
        public static EventDefinition<string, string> LogMigrationOperationOptionNotSupported(IDiagnosticsLogger logger)
        {
            var definition = ((Diagnostics.Internal.SnowflakeLoggingDefinitions)logger.Definitions).LogMigrationOperationOptionNotSupported;
            if (definition == null)
            {
                definition = NonCapturingLazyInitializer.EnsureInitialized(
                    ref ((Diagnostics.Internal.SnowflakeLoggingDefinitions)logger.Definitions).LogMigrationOperationOptionNotSupported,
                    logger,
                    static logger => new EventDefinition<string, string>(
                        logger.Options,
                        SnowflakeEventId.MigrationOperationOptionNotSupported,
                        LogLevel.Debug,
                        "SnowflakeEventId.LogMigrationOperationOptionNotSupported",
                        level => LoggerMessage.Define<string, string>(
                            level,
                            SnowflakeEventId.MigrationOperationOptionNotSupported,
                            _resourceManager.GetString("LogMigrationOperationOptionNotSupported")!)));
            }

            return (EventDefinition<string, string>)definition;
        }
    }
}
